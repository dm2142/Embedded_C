/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>

void SVC_Handler_c(uint32_t * pBaseStackFrame);

/*
 * Write a program to execute an SVC instruction from thread mode,
 * implement the SVC handler to print the SVC number used.
 */



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	// R0 contains the first operand
	__asm volatile ("LDR R0, =#20");
	// R1 Contains the second operand
	__asm volatile ("LDR R1, =#25");

	// Call the Supervisor Call to change to Handler Mode.
	__asm volatile("SVC #36");

	// When return from handler mode (SVC Handler) to thread mode, the processor loads the stack frame load before entry in Handler mode.
	uint32_t data;
	__asm volatile("MOV %0, R0": "=r"(data) ::);

	printf("The result is: %ld \n", data);

	for(;;);

}


__attribute ((naked)) void SVC_Handler(void){

	// Extract the address of stacking when an exception occurs and load into R0.
	__asm volatile ("MRS R0, MSP");
	// Call the SVC_Handler_c function, the register R0 contains the stacking address.
	__asm volatile ("B SVC_Handler_c");

}

void SVC_Handler_c(uint32_t * pBaseStackFrame){

	printf("in SVC Handler \n");

	// pBaseStackFrame contains the stacking address passed by SVC_Handler.
//	printf("The R0 address is %p \n", pBaseStackFrame);
//	printf("The R0 value is 0x%lx \n", *pBaseStackFrame);
//
//	printf("The PC (program counter address) address is %p \n", pBaseStackFrame + 6);
//	printf("The PC (program counter address) value is 0x%lx \n", pBaseStackFrame[6]);

	// Get the opcode
	uint8_t* pReturnAddress = (uint8_t*) pBaseStackFrame[6];
	pReturnAddress -= 2;

//	printf("The SVC caller address is %p \n", pReturnAddress);
//	printf("The SVC number is 0x%x \n", *pReturnAddress);

	uint8_t SVC_number = *pReturnAddress;
//	printf("The SVC number is %d \n", SVC_number);

	uint32_t a = *pBaseStackFrame;			// R0
	uint32_t b = *(pBaseStackFrame + 1);	// R1

	switch (SVC_number) {
		case 36:
			printf("Addition selected \n");
			*pBaseStackFrame = a + b;
			break;
		case 37:
			printf("Subtraction selected \n");
			*pBaseStackFrame = a - b;
			break;
		case 38:
			printf("Multiplication selected \n");
			*pBaseStackFrame = a * b;
			break;
		case 39:
			printf("Division selected \n");
			*pBaseStackFrame = a / b;
			break;
		default:
			break;
	}

}
