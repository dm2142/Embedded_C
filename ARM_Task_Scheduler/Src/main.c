/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <registers.h>
#include <tasks.h>
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/*
 * 	Define MACROS for system clock
 */

#define HSI_CLOCK			16000000U
#define SYSTICK_TIM_CLOCK	HSI_CLOCK
#define TICK_HZ				1000U

/*
 * 	Global variables
 */

TCB_t user_tasks[MAX_TASKS];
uint8_t current_task = 1;
uint32_t g_tick_count = 0;

/*
 * 	Declare prototype functions
 */

void enable_processor_faults(void);
__attribute__( (naked) ) void init_scheduler_stack(uint32_t scheduler_stack_start);
void init_tasks_stack(void);

void systick_timer_initialization(uint32_t tick_hz);

__attribute__( (naked) ) void switch_sp_to_psp(void);
uint32_t get_current_psp_value(void);
void update_g_tick_count(void);
void save_psp_value(uint32_t psp_value);
void update_task(void);
void unblock_tasks(void);



int main(void)
{

	enable_processor_faults();

	printf("The RAM end is: %x \n", SRAM_END);

	printf("The Task 1 Stack start: 0x%X \n", TASK1_STACK_START);
	printf("The Task 2 Stack start: 0x%X \n", TASK2_STACK_START);
	printf("The Task 3 Stack start: 0x%X \n", TASK3_STACK_START);
	printf("The Task 4 Stack start: 0x%X \n", TASK4_STACK_START);

	printf("The Scheduler Stack start: 0x%X \n", SCHEDULER_STACK_START);

	init_scheduler_stack(SCHEDULER_STACK_START);

	init_tasks_stack();

	systick_timer_initialization(TICK_HZ);

	switch_sp_to_psp();

	task1_handler();

}


/*
 * 	Define peripheral configurations.
 */

void systick_timer_initialization(uint32_t tick_hz){

	// Calculate the system tick reload value
	uint32_t load_value = (SYSTICK_TIM_CLOCK / tick_hz) - 1;

	// Clear system tick Reload Value register (24 bit system timer)
	uint32_t * pSys_RVR = (uint32_t*) SYST_RVR;
	*pSys_RVR &= ~(0x00FFFFFF);

	// Load the start value to count.
	*pSys_RVR |= load_value;

	// Configure the SysTick Control and Status Register
	uint32_t * pSys_CSR = (uint32_t*) SYST_CSR;

	*pSys_CSR |= (1 << 2);	// Indicates the clock source: Processor clock source.
	*pSys_CSR |= (1 << 1);	// Enables SysTick exception request.
	*pSys_CSR |= (1 << 0);	// Enables the counter.
}

__attribute__( (naked) ) void init_scheduler_stack(uint32_t scheduler_stack_start){

	__asm volatile("MSR MSP, %0": 	:"r"(scheduler_stack_start)	:	);
	__asm volatile("BX LR");
}

void init_tasks_stack(void){

	user_tasks[0].current_state = TASK_RUNNING_STATE;
	user_tasks[1].current_state = TASK_RUNNING_STATE;
	user_tasks[2].current_state = TASK_RUNNING_STATE;
	user_tasks[3].current_state = TASK_RUNNING_STATE;
	user_tasks[4].current_state = TASK_RUNNING_STATE;

	user_tasks[0].psp_value = IDLE_STACK_START;
	user_tasks[1].psp_value = TASK1_STACK_START;
	user_tasks[2].psp_value = TASK2_STACK_START;
	user_tasks[3].psp_value = TASK3_STACK_START;
	user_tasks[4].psp_value = TASK4_STACK_START;

	user_tasks[0].task_handler = idle_task;
	user_tasks[1].task_handler = task1_handler;
	user_tasks[2].task_handler = task2_handler;
	user_tasks[3].task_handler = task3_handler;
	user_tasks[4].task_handler = task4_handler;

	uint32_t* pPSP = NULL;

	for(uint8_t task = 0; task < MAX_TASKS; task ++){

		pPSP = (uint32_t*) user_tasks[task].psp_value;

		pPSP --;	// XPSR
		*pPSP = 0x01000000;	// Dummy XPSR

		pPSP --;	// PC
		*pPSP = (uint32_t) user_tasks[task].task_handler;

		pPSP --;	// LR
		*pPSP =	0xFFFFFFFD;

		// Initialization general register as 0
		for(uint8_t gen_reg = 0; gen_reg < 13; gen_reg ++){
			pPSP --;
			*pPSP = 0;
		}

		user_tasks[task].psp_value = (uint32_t) pPSP;

	}

}

void enable_processor_faults(void){

	uint32_t* pSHCSR = (uint32_t*) SHCSR;

	*pSHCSR |= (1 << 18);	// Usage fault
	*pSHCSR |= (1 << 17);	// Bus fault
	*pSHCSR |= (1 << 16);	// Mem manage

}

/*
 * 	PSP Manage Functions
 */

uint32_t get_current_psp_value(void){

	return user_tasks[current_task].psp_value;
}

void save_psp_value(uint32_t psp_value){

	user_tasks[current_task].psp_value = psp_value;

}

void update_task(void){

	uint8_t state = TASK_BLOCKED_STATE;

	for(uint8_t task = 0; task < MAX_TASKS; task ++){
		current_task ++;
		current_task %= MAX_TASKS;
		state = user_tasks[current_task].current_state;
		if( (state == TASK_RUNNING_STATE) && (current_task != 0) )
			break;
	}

	if(state != TASK_RUNNING_STATE)
		current_task = 0;

}

__attribute__( (naked) ) void switch_sp_to_psp(void){

	// Initialize PSP value with the TASK 1 stack start address.

	__asm volatile ("PUSH {LR}");	// Preserves LR which connects back to the main function.
	__asm volatile ("BL get_current_psp_value");
	__asm volatile ("MSR PSP, R0");	// Initialize the PSP
	__asm volatile ("POP {LR}");		// Retrieve LR value

	//	Change MSP to PSP
	__asm volatile ("MOV R0, #0x02");
	__asm volatile ("MSR CONTROL, R0");

	// Back to main
	__asm volatile ("BX LR");

}


/*
 * 	Define Exceptions Handlers
 */

void update_g_tick_count(void){
	g_tick_count ++;
}

void unblock_tasks(void){

	for(uint8_t task = 1; task < MAX_TASKS; task ++){

		if( (user_tasks[task].current_state == TASK_BLOCKED_STATE) && (user_tasks[task].block_count == g_tick_count)){
			user_tasks[task].current_state = TASK_RUNNING_STATE;
		}

	}

}

void SysTick_Handler(void){

	update_g_tick_count();
	unblock_tasks();

	// Set PendSV Handler
	uint32_t* pICSR = (uint32_t*) 0xE000ED04;
	*pICSR |= (0x01 << 28);

}

__attribute__((naked)) void PendSV_Handler(void){

	// SAVE THE CONTEXT OF THE TASK
	// Get the current PSP value of the task.
	__asm volatile("MRS R0, PSP");
	// Use the PSP address to store the remaining stack frame (R4 to R11)
	__asm volatile("STMDB R0!, {R4-R11}");

	// Before call another function, save the LR (linker register)
	__asm volatile("PUSH {LR}"); // Save LR into MSP

	// Save the current value of PSP (after store the remaining registers).
	__asm volatile("BL save_psp_value");

	// RETRIEVE THE CONTEXT OF THE NEXT TASK
	// Update the next task
	__asm volatile("BL update_task");
	// Get the PSP value of the next task
	__asm volatile("BL get_current_psp_value");
	// Using the task's PSP retrieve the remaining registers (R4 to R11).
	__asm volatile("LDMIA R0!, {R4-R11}");
	// Update the processor PSP value with the task PSP value before exit
	__asm volatile("MSR PSP, R0");

	// Before exit retrieve the value of LR
	__asm volatile("POP {LR}");

	// Activate the exit sequence
	__asm volatile("BX LR");

}

void MemManage_Handler(void){

	printf("MenManage Handler \n");
	while(true);
}

void BusFault_Handler(void){

	printf("BusFault Handler \n");
	while(true);
}

void UsageFault_Handler(void){

	printf("UsageFault Handler \n");
	while(true);
}

