/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>

#include "registers.h"


void delay(void);


/*
 * This code makes interface with the 4x4 Keypad, with the next configuration:
 * GPIOS PB12, 13, 14 and 15 are use as OUTPUT.
 * GPIOS PC0, 1, 2 and 3 are use as INPUT with PULL-DOWN resistors.
 */



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	/*
	 * **********************************
	 *  		Initialization
	 * **********************************
	 */

	// Create pointer for AHB1EN Register.
	RCC_AHB1ENR_t volatile * const rcc_enable_ahb1 = (RCC_AHB1ENR_t*) (RCC_REGISTER | RCC_AHB1ENR_OFFSET);

	rcc_enable_ahb1->GPIO_B_EN = 0x01;	// Enables the AHP1 Clock for PORT GPIO B.
	rcc_enable_ahb1->GPIO_C_EN = 0x01;	// Enables the AHP1 Clock for PORT GPIO C.

	printf("The pointer for RCC_REGISTER address is: %p \n", rcc_enable_ahb1);

	// Create a pointers to GPIO B and C configuration.
	GPIOx_MODER_t volatile * const p_gpio_b_moder_register = 	(GPIOx_MODER_t*) (GPIO_B_REGISTER | GPIO_MODER_OFFSET);

	GPIOx_MODER_t volatile * const p_gpio_c_moder_register = 	(GPIOx_MODER_t*) (GPIO_C_REGISTER | GPIO_MODER_OFFSET);
	GPIOx_PUPDR_t volatile * const p_gpio_c_pupd_register = 	(GPIOx_PUPDR_t*) (GPIO_C_REGISTER | GPIO_PUPDR_OFFSET);

	// Set pines 12, 13, 14 and 15 as outputs in PORT B.
	p_gpio_b_moder_register->MODER_12 = 0x01;
	p_gpio_b_moder_register->MODER_13 = 0x01;
	p_gpio_b_moder_register->MODER_14 = 0x01;
	p_gpio_b_moder_register->MODER_15 = 0x01;

	// Set pines 0, 1, 2 and 3 as inputs with pull-down resistors in PORT C.
	p_gpio_c_moder_register->MODER_0 = 0x00;
	p_gpio_c_pupd_register->PUPDR_0 = 0b00000010;
	p_gpio_c_moder_register->MODER_1 = 0x00;
	p_gpio_c_pupd_register->PUPDR_1 = 0b00000010;
	p_gpio_c_moder_register->MODER_2 = 0x00;
	p_gpio_c_pupd_register->PUPDR_2 = 0b00000010;
	p_gpio_c_moder_register->MODER_3 = 0x00;
	p_gpio_c_pupd_register->PUPDR_3 = 0b00000010;

	// ****************************************

	// Use type qualifier volatile to tells the compiler do not optimize this variable.
	volatile uint32_t * const p_gpio_b_output_data_register = (uint32_t*) (GPIO_B_REGISTER | GPIO_ODR_OFFSET);		// For modify output register in PORT B.
	const volatile uint32_t *const p_gpio_c_input_data_register = (uint32_t*) (GPIO_C_REGISTER | GPIO_IDR_OFFSET);	// For read input register in PORT C.

	volatile uint8_t row, column, index;

    /* Loop forever */
	while(true)
	{

		for( row = 0; row < 4; row ++){

			*p_gpio_b_output_data_register = (uint32_t) (0x01 << (12 + row) );
			column = (uint8_t) (*p_gpio_c_input_data_register & 0x0F);

			index = (row << 4) | (column);

			switch (index) {
				case 0x01:
					printf("1\n");
					delay();
					break;
				case 0x02:
					printf("2\n");
					delay();
					break;
				case 0x04:
					printf("3\n");
					delay();
					break;
				case 0x08:
					printf("A\n");
					delay();
					break;

				case 0x11:
					printf("4\n");
					delay();
					break;
				case 0x12:
					printf("5\n");
					delay();
					break;
				case 0x14:
					printf("6\n");
					delay();
					break;
				case 0x18:
					printf("B\n");
					delay();
					break;

				case 0x21:
					printf("7\n");
					delay();
					break;
				case 0x22:
					printf("8\n");
					delay();
					break;
				case 0x24:
					printf("9\n");
					delay();
					break;
				case 0x28:
					printf("C\n");
					delay();
					break;

				case 0x31:
					printf("*\n");
					delay();
					break;
				case 0x32:
					printf("0\n");
					delay();
					break;
				case 0x34:
					printf("#\n");
					delay();
					break;
				case 0x38:
					printf("D\n");
					delay();
					break;

				default:
					break;
			}


		}

	}
}

void delay(void){
	for(volatile uint32_t count = 0; count < 300000; count ++);
}
